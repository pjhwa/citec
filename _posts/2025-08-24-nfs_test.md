---
title: "NFS 파일시스템 부하 테스트 스크립트 작성 및 설명"
date: 2025-08-24
tags: [network, nfs, filesystem, test]
categories: [Howtos, NFS]
---

#### 배경 및 맥락 고려
- **문제 상황**: Active 서버에서 NFS 마운트된 파일시스템에 300KB 파일을 이동할 때 4초 이상의 지연(hang)이 발생. 네트워크(ping 지연 없음)와 NAS 스토리지(사용률, 응답 속도 정상)에는 이상이 없음.
- **테스트 목적**: Standby 서버에 동일한 NFS 파일시스템을 마운트한 후, 이 스크립트를 실행하여 비슷한 부하를 생성하고 hang 상태를 재현할 수 있는지 확인. 이는 NFS 클라이언트 측 설정(예: mount 옵션, timeout), 동시 쓰기 처리 능력, 또는 숨겨진 병목 현상을 검증하는 데 도움이 됩니다.
- **왜 이 스크립트인가?**: NFS는 네트워크 기반 파일시스템으로, 다중 클라이언트의 동시 쓰기 작업에서 지연이 발생할 수 있습니다. 스크립트는 병렬 프로세스를 통해 여러 파일을 동시에 생성하여 NFS 서버의 I/O 부하를 높입니다. 이는 단순 파일 이동보다 더 강한 부하를 주며, 문제 재현에 유용합니다.
- **주의사항**:
  - Standby 서버에서 NFS를 마운트할 때, active 서버와 동일한 mount 옵션을 사용하세요. 예: `mount -o vers=4,rsize=1048576,wsize=1048576,timeo=600,retrans=5 nfs_server:/path /mount_point` (NFS 버전, 읽기/쓰기 크기, 타임아웃 등을 맞춤).
  - 테스트 전: NFS 마운트 상태 확인 (`df -h`, `mount | grep nfs`), 로그 확인 (`dmesg | grep nfs`, `/var/log/messages`).
  - 부하 테스트 중: `nfsstat -c` (클라이언트 측 NFS 통계), `iostat -x 1` (디스크 I/O 모니터링), `top` 또는 `htop` (CPU/메모리 사용량)으로 모니터링하세요.
  - 안전: 테스트 디렉토리를 별도로 만들어 중요한 데이터에 영향을 주지 마세요. 파일 수를 과도하게 늘리지 말고, 단계적으로 증가시키며 테스트하세요.
  - 검증: 이 스크립트는 사실 기반으로 작성되었으며, Linux Bash 환경에서 테스트 가능합니다. 실제로 코드 실행 도구를 통해 간단한 검증을 해보았으나, 사용자 환경에 맞게 조정하세요.

#### 스크립트 설명
- **언어**: Bash (Linux 기본 쉘 스크립트).
- **기능**:
  - NFS 마운트된 디렉토리에 지정된 수만큼의 파일을 생성.
  - 각 파일은 `/dev/urandom`을 사용해 랜덤 데이터로 채워 약 300KB 크기로 만듦 (dd 명령어 사용).
  - 병렬 처리: 모든 파일 생성을 백그라운드에서 동시에 실행하여 부하를 극대화 (`&`와 `wait` 사용).
  - 옵션: 파일 수, 파일 크기, 디렉토리 경로를 인자로 받아 유연하게 조정 가능.
- **사용법**: 스크립트를 파일로 저장 (예: `nfs_load_test.sh`), 실행 권한 부여 (`chmod +x nfs_load_test.sh`),然后 실행: `./nfs_load_test.sh /mount_point 10 300` (디렉토리, 파일 수, 파일 크기 KB 단위).
- **예상 부하**: 10개 파일 simultaneous 생성 시, NFS 쓰기 지연이 발생하면 hang 재현 가능. 파일 수가 많아질수록 부하 증가.

#### 스크립트 코드
아래는 완전한 Bash 스크립트입니다. 복사하여 사용하세요.

```bash
#!/bin/bash

# 스크립트 사용법: ./nfs_load_test.sh <target_dir> <num_files> <file_size_kb>
# 예: ./nfs_load_test.sh /mnt/nfs 10 300

if [ $# -ne 3 ]; then
    echo "Usage: $0 <target_dir> <num_files> <file_size_kb>"
    echo "target_dir: NFS 마운트된 디렉토리 경로"
    echo "num_files: 생성할 파일 수 (예: 10)"
    echo "file_size_kb: 각 파일 크기 (KB 단위, 예: 300)"
    exit 1
fi

TARGET_DIR=$1
NUM_FILES=$2
FILE_SIZE_KB=$3

# 대상 디렉토리가 존재하는지 확인
if [ ! -d "$TARGET_DIR" ]; then
    echo "Error: Directory $TARGET_DIR does not exist."
    exit 1
fi

# 테스트 시작 시간 기록
START_TIME=$(date +%s)
echo "Starting NFS load test: Creating $NUM_FILES files of ${FILE_SIZE_KB}KB each in $TARGET_DIR..."

# 병렬로 파일 생성
for i in $(seq 1 $NUM_FILES); do
    FILE_NAME="$TARGET_DIR/test_file_$i.dat"
    dd if=/dev/urandom of="$FILE_NAME" bs=${FILE_SIZE_KB}K count=1 conv=fsync > /dev/null 2>&1 &
done

# 모든 백그라운드 프로세스 완료 대기
wait

# 테스트 종료 시간 기록 및 소요 시간 계산
END_TIME=$(date +%s)
ELAPSED_TIME=$((END_TIME - START_TIME))

echo "Test completed. Total time: $ELAPSED_TIME seconds."
echo "Check files in $TARGET_DIR with 'ls -lh $TARGET_DIR'."

# 옵션: 테스트 후 파일 삭제 (주석 해제 시 사용)
# rm -f $TARGET_DIR/test_file_*.dat
# echo "Cleaned up test files."
```

#### 코드 상세 설명 (이해 쉽게 단계별로)
1. **인자 확인**: 스크립트가 3개의 인자(디렉토리, 파일 수, 파일 크기)를 받는지 검증. 부족하면 사용법 출력.
2. **디렉토리 확인**: NFS 마운트된 디렉토리가 존재하는지 체크. 없으면 오류 종료.
3. **시간 측정**: 테스트 시작/종료 시간을 기록하여 전체 소요 시간을 계산. 이는 hang 상태를 정량적으로 확인하는 데 유용.
4. **파일 생성 루프**:
   - `seq 1 $NUM_FILES`: 1부터 파일 수만큼 반복.
   - `dd if=/dev/urandom of="$FILE_NAME" bs=${FILE_SIZE_KB}K count=1 conv=fsync`:
     - `if=/dev/urandom`: 랜덤 데이터 소스 (실제 쓰기 부하를 주기 위해).
     - `of="$FILE_NAME"`: 출력 파일 (예: test_file_1.dat).
     - `bs=파일크기K count=1`: 블록 크기를 KB 단위로 설정, 1번만 쓰기.
     - `conv=fsync`: 쓰기 후 즉시 디스크에 동기화 (NFS 지연을 더 잘 유발).
   - `&`: 백그라운드 실행으로 모든 dd 프로세스가 동시에 동작.
5. **wait**: 모든 병렬 프로세스가 끝날 때까지 대기.
6. **완료 메시지**: 소요 시간 출력. 파일 확인 명령어 제안.
7. **클린업 옵션**: 주석 처리된 rm 명령어로 테스트 파일 삭제 가능 (재테스트 시 유용).

#### 테스트 실행 가이드
1. **Standby 서버 준비**:
   - NFS 마운트: `sudo mount nfs_server:/export /mnt/nfs` (active 서버와 동일하게).
   - 스크립트 저장 및 실행 권한: `chmod +x nfs_load_test.sh`.
2. **초기 테스트**: 작은 파일 수로 시작. 예: `./nfs_load_test.sh /mnt/nfs 5 300`. 소요 시간 확인 (정상이라면 1-2초 내 완료, hang 시 4초 이상).
3. **부하 증가**: 파일 수를 10, 20, 50으로 늘려가며 반복. 각 실행 후 `time ./nfs_load_test.sh ...`로 시간 측정.
4. **모니터링**:
   - NFS 지연 확인: `nfsstat -c | grep -E 'write|timeout'`.
   - 시스템 로그: `tail -f /var/log/syslog | grep nfs`.
   - 네트워크: `tcpdump -i eth0 port 2049` (NFS 포트 트래픽 캡처, 별도 터미널에서).
5. **문제 재현 시 추가 검증**:
   - Mount 옵션 변경 테스트: `timeo`나 `retrans` 증가.
   - NFS 버전 확인: `nfsstat -m` (버전 3 vs 4, 4.1 등에서 차이 날 수 있음).
   - 만약 hang 발생: NFS 서버 측 로그 확인 (NAS 벤더 도구 사용).

이 스크립트는 기본적인 부하 테스트를 위해 설계되었으며, 실제 환경에서 hang을 재현하지 못하면 더 복잡한 도구(예: fio for I/O 벤치마킹)를 고려하세요. 추가 질문 있으시면 anytime 말씀해주세요!


### Active 서버 모니터링 스크립트 작성 및 설정 가이드

안녕하세요. 이전 NFS hang 문제 맥락에서 active 서버의 네트워크와 프로세스 상태를 1분마다 로그로 수집하기 위한 스크립트를 작성하겠습니다. 이는 netstat, ethtool, ps 명령어의 출력을 datetime 기반 파일명으로 저장하는 방식입니다. 스크립트는 Bash로 작성되었으며, 실수 방지를 위해 다음을 고려했습니다:

- **검증 기반 설계**: 
  - `ethtool -S` 명령어는 반드시 네트워크 인터페이스(예: eth0, enp0s3)를 지정해야 합니다. 사용자 쿼리에 인터페이스가 생략되어 있으므로, 스크립트에서 자동으로 기본 인터페이스를検출하거나 인자로 받을 수 있게 했습니다. (웹 검색을 통해 ethtool -S의 사용법을 확인: 인터페이스 필수, 예: `ethtool -S eth0`.)
  - datetime 형식: YYYYMMDD_HHMMSS로 설정하여 파일명이 unique하고 정렬하기 쉽게 함.
  - 로그 저장 디렉토리: 지정되지 않았으므로, 스크립트에서 인자로 받거나 기본값(/tmp/monitoring)으로 설정. `mkdir -p`로 디렉토리 자동 생성.
  - 명령어 정확성: netstat은 Linux에서 여전히 사용 가능하지만, deprecated일 수 있음 (ss로 대체 가능하나 쿼리대로 유지). ps auxw는 wide output을 위한 옵션으로, 오타 방지 위해 auxww로 보정 (일반적으로 auxww 사용되지만 쿼리대로 auxw 유지).
  - 에러 핸들링: 명령어가 실패할 경우(예: ethtool 인터페이스 없음) 로그에 기록.
  - cron 설정: 스크립트 자체는 한 번 실행 시 로그 생성. 1분마다 실행하려면 cron job으로 등록. (무한 루프 방식은 서버 부하를 유발할 수 있어 피함.)

- **테스트 및 검증**: 논리적으로 검증했으며, 실제 Linux 환경에서 동작 확인 가능한 코드. (예: Ubuntu/Debian/CentOS 등에서 netstat, ethtool 설치 필요: `sudo apt install net-tools ethtool` 또는 `sudo yum install net-tools ethtool`.) 스크립트 실행 시 파일 생성 여부 확인: `ls /tmp/monitoring` 등.

#### 스크립트 사용법
1. **스크립트 저장**: 파일로 저장하세요. 예: `monitor_active.sh`.
2. **실행 권한 부여**: `chmod +x monitor_active.sh`.
3. **실행 예시**:
   - 기본: `./monitor_active.sh` (기본 인터페이스 자동検출, 로그 디렉토리 /tmp/monitoring).
   - 커스텀: `./monitor_active.sh eth0 /var/log/monitoring` (인터페이스 eth0, 디렉토리 지정).
4. **cron 설정으로 1분마다 실행**:
   - `crontab -e` 명령어로 크론탭 편집.
   - 다음 줄 추가: `* * * * * /path/to/monitor_active.sh [interface] [log_dir]` (예: `* * * * * /home/user/monitor_active.sh eth0 /var/log/monitoring`).
   - 이는 매분(1분마다) 스크립트를 실행합니다. 로그가 쌓이는지 확인: `tail -f /var/log/cron` 또는 생성된 파일 목록 보기.
5. **주의사항**:
   - 루트 권한 필요: netstat -napo 등은 일부 정보(프로세스 오너)를 위해 sudo 필요할 수 있음. cron에서 sudo 사용 시 `sudo crontab -e` 또는 스크립트 내 sudo 추가.
   - 파일 누적: 장기 실행 시 디스크 공간 확인. 필요 시 오래된 파일 삭제 스크립트 추가 추천.
   - 인터페이스 확인: `ip link show`로 서버의 네트워크 인터페이스 이름 확인 (eth0, eno1 등).

#### 스크립트 코드
아래는 완전한 Bash 스크립트입니다. 복사하여 사용하세요.

```bash
#!/bin/bash

# 스크립트 사용법: ./monitor_active.sh [interface] [log_dir]
# 예: ./monitor_active.sh eth0 /var/log/monitoring
# interface: ethtool -S에 사용할 네트워크 인터페이스 (기본: 자동検출)
# log_dir: 로그 저장 디렉토리 (기본: /tmp/monitoring)

# 기본 인터페이스 자동検출 (default gateway 인터페이스)
if [ -z "$1" ]; then
    INTERFACE=$(ip route get 8.8.8.8 | awk '{print $5; exit}')
    if [ -z "$INTERFACE" ]; then
        echo "Error: Could not detect default interface. Specify as argument."
        exit 1
    fi
else
    INTERFACE=$1
fi

# 로그 디렉토리 설정
LOG_DIR=${2:-/tmp/monitoring}

# 디렉토리 생성 (이미 존재하면 무시)
mkdir -p "$LOG_DIR"

# datetime 생성 (YYYYMMDD_HHMMSS 형식)
DATETIME=$(date +%Y%m%d_%H%M%S)

# 에러 로그 파일 (문제 발생 시 기록)
ERROR_LOG="$LOG_DIR/error.$DATETIME.log"

# 명령어 실행 함수 (에러 핸들링)
run_cmd() {
    CMD=$1
    OUTPUT_FILE=$2
    $CMD > "$OUTPUT_FILE" 2>> "$ERROR_LOG"
    if [ $? -ne 0 ]; then
        echo "Error running '$CMD' at $DATETIME" >> "$ERROR_LOG"
    fi
}

# 명령어 실행
run_cmd "netstat -napo" "$LOG_DIR/netstat.napo.$DATETIME.txt"
run_cmd "netstat -s" "$LOG_DIR/netstat.s.$DATETIME.txt"
run_cmd "ethtool -S $INTERFACE" "$LOG_DIR/ethtool.S.$DATETIME.txt"
run_cmd "ps auxw" "$LOG_DIR/ps.auwx.$DATETIME.txt"

# 완료 메시지 (콘솔 또는 cron 로그에 출력)
echo "Monitoring logs saved at $DATETIME in $LOG_DIR"

# 에러 로그가 비어있지 않으면 알림 (옵션: 이메일 등으로 확장 가능)
if [ -s "$ERROR_LOG" ]; then
    echo "Errors occurred. Check $ERROR_LOG"
fi
```

#### 코드 상세 설명 (이해 쉽게 단계별로)
1. **인자 처리**: 인터페이스와 로그 디렉토리를 옵션으로 받음. 인터페이스 미지정 시 `ip route`로 자동検출 (Google DNS 8.8.8.8로 default 인터페이스 찾음 – 네트워크 연결 가정).
2. **디렉토리 생성**: `mkdir -p`로 로그 디렉토리 자동 생성. 중복 실행 시 문제 없음.
3. **datetime 생성**: `date +%Y%m%d_%H%M%S`로 파일명에 시간 스탬프 추가. 예: netstat.napo.20250822_123456.txt.
4. **에러 핸들링 함수**: 각 명령어를 함수로 wrapping. 표준 출력은 파일로, 에러는 별도 로그로. 명령어 실패 시 기록.
5. **명령어 실행**: 쿼리대로 정확히 실행. ethtool에 인터페이스 추가.
6. **완료 및 에러 확인**: 로그 저장 완료 출력. 에러 로그 확인으로 문제即시 알 수 있음.

이 스크립트는 active 서버의 상태를 지속적으로 모니터링하며, NFS hang 시점의 네트워크(소켓, 통계, NIC stats)와 프로세스 정보를 분석하는 데 유용합니다. 예를 들어, hang 발생 시 해당 datetime 파일을 확인해 TCP 재전송이나 프로세스 부하를 볼 수 있어요. 추가 수정 필요 시 말씀해주세요!
