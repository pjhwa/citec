---
title: "Apache Syncope Query로 인한 Temp Disk Full"
date: 2025-05-20
tags: [problem, bug, mariadb, apache, syncope, query]
categories: [Issues, MariaDB]
---

## 장애 개요 및 발생 과정

### **장애 현상**
- **환경**: MFA 서비스 SingleID DB (MariaDB 10.6.14, 이중화 구조, cl-ps-prd-tdb01, 02)
- **문제**: 임시 디스크(56GB)가 가득 차면서 데이터베이스 Hang 발생
- **발생 시점**: 4개의 장시간 실행 쿼리가 대규모 정렬을 유발하며 임시 디스크를 모두 소진
  - 예: 
    - `thread ID: 337423063, RUNTIME: 3046 sec`
    - `thread ID: 337418590, RUNTIME: 2985 sec`
    - `thread ID: 337425505, RUNTIME: 2925 sec`
    - `thread ID: 337427163, RUNTIME: 2986 sec`

### **발생 과정**
1. **비효율적인 쿼리 실행**: 조회 조건에 해당하는 컬럼에 인덱스가 없어 쿼리 실행 계획이 비효율적으로 변경됨. 이는 MariaDB의 통계 정보 자동 업데이트로 인해 발생.
2. **임시 디스크 소진**: 대규모 정렬 작업으로 인해 임시 디스크(56GB)가 완전히 가득 참.
3. **데이터베이스 Hang**: MariaDB 10.6.14에서는 임시 디스크가 가득 차면 공간이 확보될 때까지 최대 60초 간격으로 대기하며, 이로 인해 모든 세션이 중단됨.

---

## MariaDB 버그(MDEV-33813) 분석

### **버그 내용**
- **설명**: MDEV-33813은 임시 디스크가 가득 찬 후 공간이 확보되었음에도 후속 쿼리가 "no space left on device" 오류로 실패하는 문제를 다룸.
- **재현 조건**: Aria 스토리지 엔진에서 테스트됨. 임시 디스크가 100% 가득 찼다가 공간이 확보된 상황에서 오류 발생.
- **수정**: MariaDB 10.6.18에서 패치됨. 디스크가 가득 차면 해당 쿼리를 즉시 에러 처리하고 사용 중이던 임시 파일을 삭제하여 공간을 확보.
  - **패치 내용**: [GitHub Commit 3655cefc42](https://github.com/MariaDB/server/commit/3655cefc42)
  - **결과**: 문제가 있는 쿼리만 종료되고, 다른 세션은 정상적으로 작동.

### **SingleID 장애와의 연관성**
- **차이점**:
  - **MDEV-33813**: 디스크가 가득 찼다가 공간이 확보된 후에도 오류가 지속됨.
  - **SingleID**: 디스크가 100% 가득 찬 상태가 지속됨. 공간이 확보되지 않음.
- **버그의 역할**: SingleID에서는 디스크가 계속 100% 유지되었으므로, 버그의 "공간 확보 후 오류 지속" 시나리오와는 다름. 다만, 버그로 인해 디스크가 가득 찼을 때 쿼리가 즉시 종료되지 않고 대기 상태에 들어가면서 장애가 악화됨.

---

## 버그 픽스와 장애 방지 가능성

애플리케이션 담당자는 버그가 픽스되면 문제가 있는 쿼리를 즉시 종료(kill)하여 자원을 반납하고, 대기 중인 세션에 알림을 주어 정상 수행이 가능하다고 주장합니다. 이를 확인해보겠습니다.

### **버그 픽스 내용**
- **변경 사항**: 디스크가 가득 차면 해당 쿼리를 즉시 에러 처리하고, 사용 중이던 임시 파일을 삭제하여 공간을 확보.
- **영향**: 문제가 있는 쿼리는 실패하지만, 다른 세션은 영향을 받지 않고 정상적으로 작동.

### **SingleID 장애와의 관계**
- **장애 방지 여부**: 버그가 픽스되었다면(10.6.18 이상), 디스크가 가득 찼을 때 문제가 있는 쿼리가 즉시 종료되어 임시 파일이 삭제되고, 디스크 공간이 확보되었을 것입니다. 이로 인해 다른 세션이 대기 상태에 빠지지 않고 정상적으로 작동했을 가능성이 있습니다.
- **제한점**: 그러나 이는 **장애의 심각성을 완화**할 뿐, **근본 원인을 해결하지 않습니다**. 쿼리가 비효율적이면 여전히 많은 자원을 소모하며, 빈번한 에러 발생으로 사용자 경험에 영향을 줄 수 있습니다. 또한, 4개의 쿼리가 동시에 실행 중이었던 상황에서, 디스크가 가득 차기 전에 모든 쿼리를 종료시키는 것이 현실적으로 어려울 수 있습니다. 즉, temp 영역이 다 차기 전에 쿼리를 종료하여 장애를 완전히 방지한다는 보장은 없습니다.

---

## 각 주장의 타당성 분석

### **애플리케이션 담당자의 주장**
1. **쿼리 생성**: Apache Syncope에서 JPA로 자동 생성된 쿼리이며, 장애 전까지 문제없던 쿼리였다.
2. **버그 연관성**: MDEV-33813으로 인해 디스크가 가득 찼을 때 DB Hang이 발생했으며, 버그가 수정되었다면 다른 세션에 영향을 주지 않았을 것.
3. **영향 범위**: 버그가 없었다면 단순 느린 쿼리로 끝났을 것.

### **데이터베이스 지원 전문가의 주장**
1. **근본 원인**: 인덱스 부재로 쿼리가 비효율적으로 실행되며 임시 디스크를 소진한 것이 주원인.
2. **버그와의 차이**: MDEV-33813은 디스크가 가득 찼다가 공간이 확보된 경우를 다루지만, SingleID는 디스크가 계속 100% 유지됨.
3. **쿼리 관리 필요성**: 지속적인 쿼리 최적화가 필요하며, 버그 픽스만으로는 충분하지 않음.

### **장애 등급 판정 위원회 의견**
- 데이터 증가와 통계 정보 변화로 쿼리 실행 계획이 변하며 성능 문제가 발생할 수 있음.
- 운영 중 장시간 실행 쿼리에 대한 지속적인 관리와 개선 필요성을 강조.

---

## 판단 근거

### **근본 원인: 비효율적인 쿼리**
- **증거**: 4개의 쿼리가 각각 2900초 이상 실행되며 대규모 정렬을 유발, 임시 디스크(56GB)를 모두 소진.
- **분석**: 인덱스가 없었다면 쿼리는 전체 테이블 스캔 또는 비효율적인 정렬을 수행했을 가능성이 높음. 이는 데이터 증가와 통계 정보 업데이트로 실행 계획이 악화됨.
- **결론**: 임시 디스크가 가득 찬 것은 버그가 아니라 쿼리의 비효율성 때문.

### **버그의 역할**
- **영향**: 버그로 인해 디스크가 가득 찼을 때 쿼리가 즉시 종료되지 않고 대기 상태에 들어가면서 장애가 악화됨(10.6.14의 동작 방식).
- **제한**: 버그 픽스(10.6.18)는 디스크 소진 시 쿼리를 에러 처리하지만, 쿼리가 디스크를 소진하는 것을 막지 못함. 즉, 근본 원인을 해결하지 않음.

### **쿼리 최적화의 필요성**
- 위원회의 의견처럼, 데이터 증가와 실행 계획 변화는 피할 수 없는 현상. 지속적인 쿼리 관리와 최적화가 필요함.

**결론**: 데이터베이스 지원 전문가의 주장이 더 타당함. 버그는 장애의 심각성을 악화시켰지만, 근본 원인은 비효율적인 쿼리에 있음.

---

## 애플리케이션 담당자를 논리적으로 설득하는 반박

### **반박 1: 쿼리의 비효율성이 주원인**
- **당신의 주장**: 쿼리는 Apache Syncope에서 생성된 것이며, 장애 전까지 문제없었다.
- **반박**: 쿼리가 자동 생성되었다 하더라도, 인덱스 부재로 인해 56GB 임시 디스크를 소진한 것은 부인할 수 없는 사실입니다. 2900초 이상 실행된 쿼리는 비정상적이며, 이는 실행 계획이 비효율적으로 변경된 결과입니다. 버그가 없었다 하더라도 디스크 소진은 피할 수 없었을 것이며, 이는 근본적인 쿼리 설계 문제를 드러냅니다.

### **반박 2: 버그의 역할은 장애 악화, 원인 아님**
- **당신의 주장**: 버그로 인해 DB Hang이 발생했으며, 픽스되었다면 다른 세션에 영향을 주지 않았을 것.
- **반박**: 버그는 디스크가 가득 찼을 때 쿼리를 즉시 종료하지 않고 대기하게 만들어 장애를 악화시켰습니다(10.6.14의 60초 대기 동작). 하지만 디스크가 가득 찬 이유는 쿼리의 비효율성 때문입니다. 버그 픽스(10.6.18)는 쿼리를 에러 처리하여 다른 세션을 보호하지만, 쿼리가 디스크를 소진하는 근본 원인을 해결하지 않습니다. 즉, 버그는 결과일 뿐 원인이 아닙니다.

### **반박 3: 버그 픽스만으로는 불충분**
- **당신의 주장**: 버그가 픽스되면 문제가 있는 쿼리를 즉시 종료하여 장애를 방지할 수 있다.
- **반박**: 버그 픽스는 디스크가 가득 찼을 때 쿼리를 종료하여 장애의 심각성을 줄일 수 있습니다. 하지만 이번 장애는 4개의 쿼리가 동시에 실행되며 디스크를 소진한 경우로, 디스크가 100% 가득 차기 전에 모든 쿼리를 종료시키는 것이 현실적으로 불가능했을 가능성이 높습니다. 설령 픽스가 적용되었다 해도, 비효율적인 쿼리는 여전히 많은 자원을 소모하며 빈번한 에러를 유발할 수 있습니다. 이는 장기적인 시스템 안정성에 문제를 초래하므로, 쿼리 최적화가 필수입니다.

### **반박 4: 지속적인 관리의 중요성**
- **당신의 주장**: 버그가 없었다면 단순 느린 쿼리로 끝났을 것.
- **반박**: 2900초 이상 실행된 쿼리는 "단순 느린 쿼리"가 아닙니다. 이는 시스템 전체에 심각한 부하를 주며, 버그 없이도 성능 저하를 유발할 수 있습니다. 장애 등급 판정 위원회의 의견처럼, 데이터 증가와 실행 계획 변화는 피할 수 없는 현상입니다. 지속적인 쿼리 관리와 최적화 없이는 유사한 문제가 반복될 것입니다.

### **제안**
- **행동 방안**: 버전 업그레이드(10.6.18 이상)를 통해 버그를 수정하는 동시에, 인덱스를 추가하고 쿼리 실행 계획을 정기적으로 모니터링하세요. 데이터 증가를 고려한 설계와 최적화를 병행해야 합니다. 버그 픽스는 보조적 조치일 뿐, 근본 해결책은 쿼리 관리에 있습니다. 두 가지 접근을 결합하면 재발을 확실히 방지할 수 있습니다.

---

## 결론

데이터베이스 지원 전문가의 입장이 옳으며, 장애의 근본 원인은 인덱스 없는 비효율적인 쿼리입니다. MariaDB 버그(MDEV-33813)는 장애의 심각성을 악화시켰을 뿐, 주원인이 아닙니다. 버그 픽스와 쿼리 최적화를 모두 수행하여 재발을 방지해야 합니다. 애플리케이션 담당자의 버그 관련 지적은 유효하지만, 쿼리 최적화 없이는 장기적인 안정성을 보장할 수 없음을 인지해야 합니다.
